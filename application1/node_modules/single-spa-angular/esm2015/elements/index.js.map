{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../libs/single-spa-angular/elements/src/index.ts"],"names":[],"mappings":";AAEA,OAAO,EAEL,iCAAiC,GAClC,MAAM,8BAA8B,CAAC;AAItC,MAAM,cAAc,GAAgD;IAClE,OAAO,EAAE,IAAI;IACb,QAAQ,EAAE,IAAK;IACf,WAAW,EAAE,IAAI;IACjB,iBAAiB,EAAE,IAAK;IACxB,gBAAgB,EAAE,SAAS;CAC5B,CAAC;AAEF,SAAe,SAAS,CAAC,OAAoD,EAAE,KAAU;;QACvF,IAAI,OAAO,CAAC,WAAW,KAAK,IAAI,EAAE;YAChC,OAAO;SACR;QAED,oEAAoE;QACpE,gEAAgE;QAChE,0BAA0B;QAC1B,OAAO,CAAC,WAAW,GAAG,MAAM,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAC/D,CAAC;CAAA;AAED,SAAe,KAAK,CAAC,OAAoD,EAAE,KAAU;;QACnF,MAAM,gBAAgB,GAAG,iCAAiC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAC3E,4EAA4E;QAC5E,qEAAqE;QACrE,qBAAqB;QACrB,OAAO,CAAC,OAAO,GAAG,gBAAgB,CAAC,iBAA8B,CAAC;IACpE,CAAC;CAAA;AAED,SAAS,OAAO,CAAC,OAAoD;IACnE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE;QACjC,mEAAmE;QACnE,mEAAmE;QACnE,OAAO,CAAC,OAAQ,CAAC,aAAc,CAAC,WAAW,CAAC,OAAO,CAAC,OAAQ,CAAC,CAAC;QAC9D,OAAO,CAAC,OAAO,GAAG,IAAI,CAAC;IACzB,CAAC,CAAC,CAAC;AACL,CAAC;AAED,MAAM,UAAU,wBAAwB,CAAC,WAAwC;IAC/E,MAAM,OAAO,mCACR,cAAc,GACd,WAAW,CACf,CAAC;IAEF,OAAO;QACL,SAAS,EAAE,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC;QACxC,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC;QAChC,OAAO,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC;KACrC,CAAC;AACJ,CAAC","sourcesContent":["import { LifeCycles } from 'single-spa';\nimport { NgElement } from '@angular/elements';\nimport {\n  BaseSingleSpaAngularOptions,\n  getContainerElementAndSetTemplate,\n} from 'single-spa-angular/internals';\n\nimport { BootstrappedSingleSpaAngularElementsOptions } from './types';\n\nconst defaultOptions: BootstrappedSingleSpaAngularElementsOptions = {\n  element: null,\n  template: null!,\n  ngModuleRef: null,\n  bootstrapFunction: null!,\n  domElementGetter: undefined,\n};\n\nasync function bootstrap(options: BootstrappedSingleSpaAngularElementsOptions, props: any) {\n  if (options.ngModuleRef !== null) {\n    return;\n  }\n\n  // We call `bootstrapFunction()` inside the bootstrap lifecycle hook\n  // because Angular modules that expose custom elements should be\n  // bootstrapped only once.\n  options.ngModuleRef = await options.bootstrapFunction(props);\n}\n\nasync function mount(options: BootstrappedSingleSpaAngularElementsOptions, props: any) {\n  const containerElement = getContainerElementAndSetTemplate(options, props);\n  // `options.template` which can be `<app-element />` is not a valid selector\n  // for `document.querySelector`, thus we retrieve this custom element\n  // via this property.\n  options.element = containerElement.firstElementChild as NgElement;\n}\n\nfunction unmount(options: BootstrappedSingleSpaAngularElementsOptions): Promise<void> {\n  return Promise.resolve().then(() => {\n    // Removing custom element from DOM is enough since it will trigger\n    // `disconnectedCallback()` and Angular will dispose all resources.\n    options.element!.parentElement!.removeChild(options.element!);\n    options.element = null;\n  });\n}\n\nexport function singleSpaAngularElements(userOptions: BaseSingleSpaAngularOptions): LifeCycles {\n  const options: BootstrappedSingleSpaAngularElementsOptions = {\n    ...defaultOptions,\n    ...userOptions,\n  };\n\n  return {\n    bootstrap: bootstrap.bind(null, options),\n    mount: mount.bind(null, options),\n    unmount: unmount.bind(null, options),\n  };\n}\n"]}