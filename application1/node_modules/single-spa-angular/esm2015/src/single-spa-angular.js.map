{"version":3,"file":"single-spa-angular.js","sourceRoot":"","sources":["../../../libs/single-spa-angular/src/single-spa-angular.ts"],"names":[],"mappings":"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","sourcesContent":["import { NgModuleRef, NgZone } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { LifeCycles } from 'single-spa';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\n\nimport { SingleSpaPlatformLocation } from './extra-providers';\nimport { SingleSpaAngularOptions, BootstrappedSingleSpaAngularOptions } from './types';\n\nconst defaultOptions = {\n  // Required options that will be set by the library consumer.\n  NgZone: null!,\n  bootstrapFunction: null!,\n  template: null!,\n  // Optional options\n  Router: undefined,\n  domElementGetter: undefined, // only optional if you provide a domElementGetter as a custom prop\n  updateFunction: () => Promise.resolve(),\n  bootstrappedModule: null,\n};\n\nexport function singleSpaAngular<T>(userOptions: SingleSpaAngularOptions<T>): LifeCycles<T> {\n  if (typeof userOptions !== 'object') {\n    throw Error('single-spa-angular requires a configuration object');\n  }\n\n  const options: SingleSpaAngularOptions = {\n    ...defaultOptions,\n    ...userOptions,\n  };\n\n  if (typeof options.bootstrapFunction !== 'function') {\n    throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n  }\n\n  if (typeof options.template !== 'string') {\n    throw Error('single-spa-angular must be passed options.template string');\n  }\n\n  if (!options.NgZone) {\n    throw Error(`single-spa-angular must be passed the NgZone option`);\n  }\n\n  if (options.Router && !options.NavigationStart) {\n    // We call `console.warn` except of throwing `new Error()` since this will not\n    // be a breaking change.\n    console.warn(`single-spa-angular must be passed the NavigationStart option`);\n  }\n\n  return {\n    bootstrap: bootstrap.bind(null, options as BootstrappedSingleSpaAngularOptions),\n    mount: mount.bind(null, options),\n    unmount: unmount.bind(null, options as BootstrappedSingleSpaAngularOptions),\n    update: options.updateFunction,\n  };\n}\n\nasync function bootstrap(options: BootstrappedSingleSpaAngularOptions, props: any): Promise<void> {\n  // Angular provides an opportunity to develop `zone-less` application, where developers\n  // have to trigger change detection manually.\n  // See https://angular.io/guide/zone#noopzone\n  if (options.NgZone === 'noop') {\n    return;\n  }\n\n  // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.\n  options.zoneIdentifier = `single-spa-angular:${props.name || props.appName}`;\n\n  // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.\n  // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,\n  // https://github.com/single-spa/single-spa-angular/issues/47,\n  // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,\n  // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257\n  options.NgZone.isInAngularZone = () => {\n    // @ts-ignore\n    return window.Zone.current._properties[options.zoneIdentifier] === true;\n  };\n\n  options.routingEventListener = () => {\n    options.bootstrappedNgZone!.run(() => {\n      // See https://github.com/single-spa/single-spa-angular/issues/86\n      // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n      // unless we tell Zone that something happened\n    });\n  };\n}\n\nasync function mount(options: SingleSpaAngularOptions, props: any): Promise<NgModuleRef<any>> {\n  getContainerElementAndSetTemplate(options, props);\n\n  const bootstrapPromise = options.bootstrapFunction(props);\n\n  if (!(bootstrapPromise instanceof Promise)) {\n    throw Error(\n      `single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`,\n    );\n  }\n\n  const module: NgModuleRef<any> = await bootstrapPromise;\n\n  if (!module || typeof module.destroy !== 'function') {\n    throw Error(\n      `single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module. Did you call platformBrowserDynamic().bootstrapModule() correctly?`,\n    );\n  }\n\n  const singleSpaPlatformLocation: SingleSpaPlatformLocation | null = module.injector.get(\n    SingleSpaPlatformLocation,\n    null,\n  );\n\n  const ngZoneEnabled = options.NgZone !== 'noop';\n\n  // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n  // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n  // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n  // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n  if (ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n    throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n  }\n\n  const bootstrappedOptions = options as BootstrappedSingleSpaAngularOptions;\n\n  if (ngZoneEnabled) {\n    const ngZone: NgZone = module.injector.get(options.NgZone);\n    const zoneIdentifier: string = bootstrappedOptions.zoneIdentifier!;\n\n    // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n    // function was not called.\n    if (singleSpaPlatformLocation !== null) {\n      skipLocationChangeOnNonImperativeRoutingTriggers(module, options);\n    }\n\n    bootstrappedOptions.bootstrappedNgZone = ngZone;\n    bootstrappedOptions.bootstrappedNgZone['_inner']._properties[zoneIdentifier] = true;\n    window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener!);\n  }\n\n  bootstrappedOptions.bootstrappedModule = module;\n  return module;\n}\n\nfunction unmount(options: BootstrappedSingleSpaAngularOptions): Promise<void> {\n  return Promise.resolve().then(() => {\n    if (options.routingEventListener) {\n      window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n    }\n\n    options.bootstrappedModule!.destroy();\n    options.bootstrappedModule = null;\n  });\n}\n\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(\n  module: NgModuleRef<any>,\n  options: SingleSpaAngularOptions,\n): void {\n  if (!options.NavigationStart) {\n    // As discussed we don't do anything right now if the developer doesn't provide\n    // `options.NavigationStart` since this might be a breaking change.\n    return;\n  }\n\n  const router = module.injector.get(options.Router);\n  const subscription: Subscription = router.events.subscribe((event: any) => {\n    if (event instanceof options.NavigationStart!) {\n      const currentNavigation = router.getCurrentNavigation();\n      // This listener will be set up for each Angular application\n      // that has routing capabilities.\n      // We set `skipLocationChange` for each non-imperative navigation,\n      // Angular router checks under the hood if it has to change\n      // the browser URL or not.\n      // If `skipLocationChange` is truthy then Angular router will not call\n      // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n      if (currentNavigation.trigger !== 'imperative') {\n        currentNavigation.extras.skipLocationChange = true;\n        currentNavigation.extras.replaceUrl = false;\n      }\n    }\n  });\n\n  module.onDestroy(() => {\n    subscription.unsubscribe();\n  });\n}\n"]}